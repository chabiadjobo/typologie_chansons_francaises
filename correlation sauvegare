
# 1. Fonction pour le test de normalité
def test_normality(df, column):
    stat, p = stats.shapiro(df[column].dropna())
    is_normal = p > 0.05
    print(f"Test de normalité pour '{column}' : {'Normale' if is_normal else 'Non Normale'}")
    return is_normal

# 2. Fonction pour la visualisation de la relation entre deux variables
def visualiser_relation(df, var1, var2, mode='manuel'):
    # Création de la figure avec plusieurs sous-graphiques
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    # 1. Ajustement linéaire
    sns.regplot(x=df[var1], y=df[var2], ax=axes[0], line_kws={"color": "red"}, ci=None)
    axes[0].set_title("Ajustement Linéaire")
    
    # 2. Ajustement quadratique
    poly_fit = np.poly1d(np.polyfit(df[var1], df[var2], 2))
    df['var1_squared'] = df[var1] ** 2
    sns.scatterplot(x=df[var1], y=df[var2], ax=axes[1])
    sns.lineplot(x=df[var1], y=poly_fit(df[var1]), ax=axes[1], color="green")
    axes[1].set_title("Ajustement Quadratique")
    
    # 3. Ajustement cubique
    poly_fit_cubic = np.poly1d(np.polyfit(df[var1], df[var2], 3))
    sns.scatterplot(x=df[var1], y=df[var2], ax=axes[2])
    sns.lineplot(x=df[var1], y=poly_fit_cubic(df[var1]), ax=axes[2], color="blue")
    axes[2].set_title("Ajustement Cubique")

    plt.suptitle(f"Comparaison des Ajustements pour {var1} et {var2}")
    plt.tight_layout()
    plt.show()

    # En mode automatique, choisir un type de relation par défaut
    if mode == 'auto':
        if test_normality(df, var1) and test_normality(df, var2):
            return '1'  # Ajustement linéaire par défaut
        else:
            return '2'  # Ajustement quadratique par défaut
    else :
    # En mode manuel, demander à l'utilisateur de choisir le type de relation
        print("\nQuel type de relation vous semble le plus adapté entre '{}' et '{}' ?".format(var1, var2))
        print("1 : Ajustement Linéaire")
        print("2 : Ajustement Quadratique")
        print("3 : Ajustement Cubique")
        print("4 : Non Linéaire ou Autre")
        relation_type = input("Choisissez une option (1, 2, 3 ou 4) : ")
    
        return relation_type


# 3. Fonction pour choisir la méthode de corrélation
def choisir_correlation(normal_var1, normal_var2, relation_type):
    if normal_var1 and normal_var2 and relation_type == '1':
        return "pearson"
    elif relation_type == '1':  # Linéaire mais pas normal
        return "spearman"
    elif relation_type == '2':
        return "Quadratique"
    elif relation_type == '3':
        return "kendall"
    else:
        return "Distance Corrélation"  # Placeholder

# 4. Fonction pour calculer la corrélation
def calculer_correlation(method, df, var1, var2):
    if method == "pearson":
        return df[var1].corr(df[var2], method='pearson')
    elif method == "spearman":
        return df[var1].corr(df[var2], method='spearman')
    elif method == "kendall":
        return df[var1].corr(df[var2], method='kendall')
    elif method == "Quadratique":
        # Ajustement d'une régression quadratique
        df['var1_squared'] = df[var1] ** 2
        # Utilisation des noms corrects pour les colonnes
        X = sm.add_constant(df[[var1, 'var1_squared']])
        model = sm.OLS(df[var2], X).fit()
        return model.rsquared  # Retourne R² pour l'ajustement quadratique
    elif method == "Distance Corrélation":
        try:
            return dcor.distance_correlation(df[var1].values, df[var2].values)
        except ImportError:
            print("Distance Corrélation non implémentée. Utilisation d'une méthode alternative.")
            return mutual_info_score(df[var1].astype(str), df[var2].astype(str))
    else:
        raise ValueError(f"Méthode de corrélation '{method}' non reconnue.")


# 5. Fonction pour le test d'hétéroscédasticité
def test_heteroscedasticity(df, var1, var2):
    X = sm.add_constant(df[var1])
    y = df[var2]
    model = sm.OLS(y, X).fit()
    test = het_breuschpagan(model.resid, X)
    p_value = test[1]
    is_homoscedastic = p_value > 0.05
    print(f"Test d'hétéroscédasticité (Breusch-Pagan) : {'Homoscedastique' if is_homoscedastic else 'Hétéroscédastique'}")
    return is_homoscedastic

# 6. Fonction pour le test de significativité de la corrélation
def test_significance(df, var1, var2, method, corr_value):
    n = len(df.dropna(subset=[var1, var2]))
    if method in ["pearson", "spearman"]:
        t_stat = corr_value * ((n-2) ** 0.5) / ((1 - corr_value**2) ** 0.5)
        p_value = 2 * (1 - stats.t.cdf(abs(t_stat), df=n-2))
    elif method == "kendall":
        p_value = stats.kendalltau(df[var1], df[var2])[1]
    else:
        return None  # Pour les méthodes non standards
    return p_value

# 7. Fonction pour visualiser la heatmap de corrélation
def heatmap_corr(df, var1, var2, correlation_method):
    if correlation_method in ["pearson", "spearman", "kendall"]:
        corr_matrix = df[[var1, var2]].corr(method=correlation_method)
        plt.figure(figsize=(5, 4))
        sns.heatmap(corr_matrix, annot=True, cmap='coolwarm')
        plt.title(f"Matrice de corrélation ({correlation_method}) entre {var1} et {var2}")
        plt.show()
    else:
        print("Visualisation de heatmap non disponible pour les méthodes non standards (Distance Corrélation, Mutual Information, etc.)")

# 8. Fonction principale qui coordonne l'analyse complète entre deux variables
def analyser_correlation(df, var1, var2, mode='manual'):
    # Test de normalité
    normal_var1 = test_normality(df, var1)
    normal_var2 = test_normality(df, var2)

    if mode == 'auto':
        # Choix automatique de la méthode de corrélation
        correlation_method = choisir_correlation(normal_var1, normal_var2, "1")  # Juste un placeholder pour l'option
        print(f"Méthode de corrélation suggérée (mode auto) : {correlation_method}")
    else:
        # Visualisation de la relation
        relation_type = visualiser_relation(df, var1, var2)
        # Choix de la méthode de corrélation
        correlation_method = choisir_correlation(normal_var1, normal_var2, relation_type)
        print(f"Méthode de corrélation suggérée : {correlation_method}")

    # Calcul de la corrélation
    correlation_value = calculer_correlation(correlation_method, df, var1, var2)
    print(f"Valeur de corrélation ({correlation_method}) : {correlation_value}")

    # Test d'hétéroscédasticité
    test_heteroscedasticity(df, var1, var2)

    # Test de significativité
    significance_p_value = test_significance(df, var1, var2, correlation_method, correlation_value)
    if significance_p_value is not None:
        print(f"Test de significativité : p-value = {significance_p_value}")
        if significance_p_value < 0.05:
            print("La corrélation est statistiquement significative (p < 0.05).")
        else:
            print("La corrélation n'est pas statistiquement significative (p >= 0.05).")

    # Visualisation de la heatmap
    heatmap_corr(df, var1, var2, correlation_method)

# 9. Fonction pour remplacer la probabilité par des étoiles
def niveau_significativite(p_value):
    """Convertit une p-value en niveau d'étoile."""
    if p_value is None:
        return 'Inconnu'  # Indiquer que la p-value est inconnue
    elif p_value < 0.001:
        return '⭐⭐⭐'
    elif p_value < 0.01:
        return '⭐⭐'
    elif p_value < 0.05:
        return '⭐'
    else:
        return 'Aucune'

# 10. Fonction qui coordonne l'analyse complète entre plusieurs variables
def analyser_correlation_multiple(df, variables, mode='manuel'):
    # Initialiser une liste pour stocker les résultats
    results = []

    # Itérer sur toutes les combinaisons de variables
    for i in range(len(variables)):
        for j in range(i + 1, len(variables)):
            var1 = variables[i]
            var2 = variables[j]

            # Test de normalité
            normal_var1 = test_normality(df, var1)
            normal_var2 = test_normality(df, var2)

            # En mode automatique, déterminer le type de relation sans interaction utilisateur
            if mode == 'auto':
                relation_type = visualiser_relation(df, var1, var2, mode='auto')  # pas d'interaction ici
                correlation_method = choisir_correlation(normal_var1, normal_var2, relation_type)
            else:
                # Visualisation de la relation
                relation_type = visualiser_relation(df, var1, var2, mode='manuel')
                # Choix de la méthode de corrélation basé sur le mode
                correlation_method = input(f"Choisissez la méthode de corrélation entre {var1} et {var2} : ")

            print(f"Méthode de corrélation choisie : {correlation_method}")

            # Calcul de la corrélation
            correlation_value = calculer_correlation(correlation_method, df, var1, var2)
            print(f"Valeur de corrélation ({correlation_method}) : {correlation_value}")

            # Test d'hétéroscédasticité
            test_heteroscedasticity(df, var1, var2)

            # Test de significativité
            significance_p_value = test_significance(df, var1, var2, correlation_method, correlation_value)
            star_rating = niveau_significativite(significance_p_value) if significance_p_value is not None else None

            # Ajout des résultats à la liste
            results.append({
                'Variable 1': var1,
                'Variable 2': var2,
                'Méthode de Corrélation': correlation_method,
                'Valeur de Corrélation': correlation_value,
                'P-value': significance_p_value,
                'Niveau d\'étoiles': star_rating
            })

    # Convertir les résultats en DataFrame pour un affichage plus facile
    results_df = pd.DataFrame(results)
    return results_df


    # Convertir les résultats en DataFrame pour un affichage plus facile
    results_df = pd.DataFrame(results)
    return results_df
